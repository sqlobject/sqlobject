TODO
----

* Proper %-encoded URI.

* __version__.py

* Release 1.0.

* Decorators @classmethod and @staticmethod.

* Declare one encoding for all UnicodeCol's per table or even per connection.
  Don't forget about fromDatabase.

* Allow to override ConsoleWriter/LogWriter classes and makeDebugWriter
  function.

* delColumn('foreignKey'), delColumn('foreignKeyID')

* ForeignKey('Table', otherColumn='other_id') to allow ForeignKey to
  point to a non-id column.

* RelatedJoin.hasOther(otherObject[.id])

* tableParamSQL::

    class MyTable(SQLObject):
       class sqlmeta:
          tableParamSQL = 'ENGINE InnoDB'
          tableParamSQL = {'mysql': 'ENGINE InnoDB'}

* List tables in the DB. The query in MySQL is ``SHOW TABLES``; in SQLite it is

    SELECT name FROM sqlite_master WHERE type='table' ORDER BY name

  and in Postgres it is something like

    SELECT c.relname FROM pg_class c, pg_type t
    WHERE c.reltype = t.oid AND t.typname = 'table'.

* List databases in the connection.

* IntervalCol

* TimedeltaCol

* Invert tests isinstance(obj, (tuple, list)) to not isinstance(obj, basestr)
  to allow any iterable.

* SQLObject.fastInsert().

* Always use .lazyIter().

* Optimize Iteration.next() - use cursor.fetchmany().

* Generators instead of loops (fetchall => fetchone).

* Cache columns in sqlmeta.getColumns(); reset the cache on add/Del Column/Join.

* Stop supporting Python 2.4: use ``with lock``; use hashlib instead of md5.

* Stop supporting Python 2.5: remove import sets.

* Expression columns - in SELECT but not in INSERT/UPDATE. Something like this::

    class MyClass(SQLObject):
        function1 = ExpressionCol(func.my_function(MyClass.q.col1))
        function2 = ExpressionCol('sum(col2)')

* Catch all DB API exceptions and convert them to sqlobject.dberrors.

* Memcache.

* Parametrized queries.

* PREPARE/EXECUTE

* Protect all .encode(), catch UnicodeEncode exceptions and reraise Invalid.

* Better joins - automatic joins in .select()
  based on ForeignKey/MultipleJoin/RelatedJoin.

* Python 3.0+.

* Switch from setuptools to distribute.

* py-postgresql driver: http://python.projects.postgresql.org/

* MySQL Connector/Python: https://launchpad.net/myconnpy

* oursql MySQL bindings: https://launchpad.net/oursql

* pyfirebirdsql: https://github.com/nakagami/pyfirebirdsql

* dict API: use getitem interface for column access instead of getattr; reserve
  getattr for internal attributes only; this helps to avoid collisions with
  internal attributes.

* Or move column values access to a separate namespace, e.g. .c: row.c.name.

* More documentation. Wiki. Trac. Mercurial.

* RSS 2.0 and Atom news feeds.

* Use DBUtils_, especially SolidConnection.

.. _DBUtils: http://www.webwareforpython.org/DBUtils

* ``_fromDatabase`` currently doesn't support IDs that don't fit into
  the normal naming scheme.  It should do so.  You can still use
  ``_idName`` with ``_fromDatabase``.

* More databases supported.  There has been interest and some work in
  the progress for Oracle. IWBN to have Informix and DB2 drivers.

* Better transaction support -- right now you can use transactions
  for the database, but the object isn't transaction-aware, so
  non-database persistence won't be able to be rolled back.

* Optimistic locking and other techniques to handle concurrency.

* Profile of SQLObject performance, so that I can identify bottlenecks.

* Increase hooks with FormEncode validation and form generation package, so
  SQLObject classes (read: schemas) can be published for editing more
  directly and easily.  (First step: get Schema-generating method into
  sqlmeta class)

* Automatic joins in select queries.

* More kinds of joins, and more powerful join results (closer to how
  `select` works).

* Refactor ``DBConnection`` to use parameterized queries instead of
  generating query strings.

* A hierarchy of exceptions. SQLObject should translate exceptions from
  low-level drivers to a consistent set of high-level exceptions.

* Merge SQLObject.create*, .create*SQL methods with DBPI.create* methods.

* Made SQLObject unicode-based instead of just unicode-aware. All internal
  processing should be done with unicode strings, conversion to/from ascii
  strings should happen for non-unicode DB API drivers.

.. image:: http://sflogo.sourceforge.net/sflogo.php?group_id=74338&type=10
   :target: http://sourceforge.net/projects/sqlobject
   :class: noborder
   :align: center
   :height: 15
   :width: 80
   :alt: Get SQLObject at SourceForge.net. Fast, secure and Free Open Source software downloads
